###Module
id seed_distance
component seed_distance
flags {lib, distance}
par {d_bound: 5.0, eye: -1.5, alpha: 1.0}
modules {seed_color:tex_simple, df:df_sphere, distance_light: light1, a: alpha_solid}
sub {d_max_steps:400, d_epsilon:0.00001}

###Component
id seed_distance
family seed
default_mod seed_distance
children {seed_color:seed_color, df:distance_field, distance_light: distance_light, a:a}
code &&&

vec3 df;

seed = vec4(0.0);

vec3 r_eye = vec3(0.0, 0.0, |eye|);
vec3 r_dir = normalize(vec3(z.x, z.y, 1.0));

// intersect ray
float l = 0.0;

for (int count=0; count < ~d_max_steps~; count += 1) {
  vec3 pos = r_eye + l * r_dir;

  /*
  float c = cos(5.0*pos.y);
  float s = sin(5.0*pos.y);
  mat2  m = mat2(c,-s,s,c);
  pos = vec3(m*pos.xz,pos.y);
  */

  /*
  vec3 c = vec3(3.0, 3.0, 3.0);
  pos = mod(pos, c) - 0.5 * c;
  */

  %df%

  float dist = df.z;

  // we have a hit
  if (dist < ~d_epsilon~){
    vec3 pos_orig = pos;
    vec2 ofs = df.xy;

    // calculate normal
    vec3 ep = vec3(0.001, 0.0, 0.0);
    vec3 nor = vec3(0.0, 0.0, 0.0);

    // nor.x
    pos = pos_orig + ep.xyy;
    %df%
    float norx1 = df.z;

    pos = pos_orig - ep.xyy;
    %df%
    float norx2 = df.z;
    nor.x = norx1 - norx2;

    // nor.y
    pos = pos_orig + ep.yxy;
    %df%
    float nory1 = df.z;

    pos = pos_orig - ep.yxy;
    %df%
    float nory2 = df.z;
    nor.y = nory1 - nory2;

    // nor.z
    pos = pos_orig + ep.yyx;
    %df%
    float norz1 = df.z;

    pos = pos_orig - ep.yyx;
    %df%
    float norz2 = df.z;
    nor.z = norz1 - norz2;

    nor = normalize(nor);
    pos = pos_orig;

    // compute phong lighting
    vec3 light = vec3(0.0);
    %distance_light%

    // alpha
		float a = 1.0;
		%a%

    // get texture/seed value
		float w = 1.0;
    %seed_color%

    seed = vec4(light, 1.0) * seed;

    break;
  }

  l += dist;

  if (l > |d_bound|)
     break;
}
