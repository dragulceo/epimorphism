### Component
id distance_util
family ibrary
code &&&

vec4 df(vec3 p, float time) {
  float d = 0.6;

  p = rotate3D(p, vec3(1.0, 0.3, -0.2), time / 8.0);
  vec3 sc = p / vec3(d, d, d);
  
  vec2 ofs;
  if(abs(sc.z) > 1.0)
    ofs = sc.xy;
  else if(abs(sc.x) > 1.0)
    ofs = sc.yz;
  else
    ofs = sc.zx;
  ofs = (ofs + vec2(1.0, 1.0)) / vec2(2.0, 2.0);      
    
  //float l = length(max(abs(p) - vec3(d, d, d), 0.0));
  float l = length(p) - 1.0;

  //vec2 q = vec2(length(p.xy) - d, p.z);
  //float l = length(q) - d * 0.5;
  
  return vec4(ofs, 0.0, l);
}

#define D_EPSILON 0.00001
#define D_MAX_STEPS 200
#define D_BOUND 2.0

vec4 inter(vec3 r_origin, vec3 r_dir, float time) {
  float l = 0.0;
  
  for (int count=0; count < D_MAX_STEPS; count += 1) {
    vec3 pos = r_origin + l * r_dir;
    vec4 res = df(pos, time);
    float dist = res.w;
    
    if (dist < D_EPSILON)
      return vec4(res.xy, 0.0, l);    

    l += dist;
    
    if (l > D_BOUND) return vec4(0.0, 0.0, 0.0, -1.0);
  }
  return vec4(0.0, 0.0, 0.0, -1.0);
}

vec3 calcNormal(vec3 p, float time) {
  vec3 e = vec3(0.001, 0.0, 0.0);
  vec3 n;
  n.x = df(p+e.xyy, time).w - df(p-e.xyy, time).w;
  n.y = df(p+e.yxy, time).w - df(p-e.yxy, time).w;
  n.z = df(p+e.yyx, time).w - df(p-e.yyx, time).w;

  return normalize(n);
}