###Module
id seed_distance
component seed_distance
flags {lib, distance}
par {d: wave 0.044 0.1 0.45, shininess:0.05}
modules {tex:tex_simple, df:df_sphere}

###Component
id seed_distance
family seed
default_mod seed_distance
children {tex:seed_color, df:distance_field}
code &&&

#define D_EPSILON 0.00001
#define D_MAX_STEPS 400
#define D_BOUND 2.0

vec4 df;

seed = vec4(0.0, 0.0, 0.0, 0.0);

vec3 r_eye = vec3(0.0, 0.0, -1.5);
vec3 r_dir = normalize(vec3(z.x, z.y, 1.0));

float d = |d|;

// intersect ray
float l = 0.0;

for (int count=0; count < D_MAX_STEPS; count += 1) {
  vec3 pos = r_eye + l * r_dir;

  %df%

  float dist = df.w;

  // we have a hit
  if (dist < D_EPSILON){
     vec2 ofs = df.xy;

     // calculate normal
     vec3 ep = vec3(0.001, 0.0, 0.0);
     vec3 nor = vec3(0.0, 0.0, 0.0);
     vec3 pos_orig = pos;

     // nor.x
     pos = pos_orig + ep.xyy;
     %df%
     float norx1 = df.w;

     pos = pos_orig - ep.xyy;
     %df%
     float norx2 = df.w;
     nor.x = norx1 - norx2;

     // nor.y
     pos = pos_orig + ep.yxy;
     %df%
     float nory1 = df.w;

     pos = pos_orig - ep.yxy;
     %df%
     float nory2 = df.w;
     nor.y = nory1 - nory2;

     // nor.z
     pos = pos_orig + ep.yyx;
     %df%
     float norz1 = df.w;

     pos = pos_orig - ep.yyx;
     %df%
     float norz2 = df.w;
     nor.z = norz1 - norz2;

     nor = normalize(nor);

     // get texture/seed value
     %tex%

     // compute phong lighting
     vec3 light = vec3(0.0);

     // somewhat arbitrary lighting positions & colors
     vec3 light_pos   = vec3(5.0, 5.0, -8.0);
     vec3 light_color = vec3(1.0, 0.7, 0.7);

     // vary specular & diffuse component via red channel (a bit arbitrary)
     vec3 vl = normalize(light_pos - pos + vec3(seed.r));
     vec3 ev = normalize(l * r_dir);
     vec3 ref_ev = reflect(ev, nor);

     float diffuse  = max(0.0, dot(vl, nor));
     float specular = max(0.0, dot(vl, ref_ev));

     // vary specular even farther by seed luminosity
     float v = (seed.r + seed.g + seed.b) / 3.0;
     specular = pow(specular, v / |shininess|);

     light += light_color * (diffuse + specular);

     // illuminate texture
     seed = vec4(light, 1.0) * seed;

     break;
  }

  l += dist;

  if (l > D_BOUND)
     break;
}