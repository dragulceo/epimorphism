### Module
id seed_distance
component seed_distance
flags {lib, distance}
par {d_bound: 3.0, eye: -1.5, l_exp: 3.0, ao_del: 0.01, ao_k:2.0, refl:0.0}
modules {seed_color:tex_simple0, df:df_torus, distance_light: light1, a:alpha_solid}
sub {d_max_steps:200, d_epsilon:0.00001}

### Component
id seed_distance
family seed
default_mod seed_distance
children {seed_color:seed_color, df:distance_field, distance_light: distance_light, a:a}
code &&&
seed = vec4(0.0);

vec4 df, df_hit, df0, df1, seed0, seed1;
vec3 pos, pos_hit, nor, light, light0, light1, light_pos;
vec2 ofs, ofs0, ofs1;
float surface, a, w;

// shoot rays!
int hit = 0;
float l = 0.0;
vec3 r_eye = vec3(0.0, 0.0, |eye|);
vec3 r_dir = normalize(vec3(z.x, z.y, 1.0));

for (int count=0; count < ~d_max_steps~; count += 1) {
	pos = r_eye + l * r_dir;
	pos_hit = pos;

  surface = -1.0;
  %df%

  // we have a hit
  if (df.z < ~d_epsilon~){
    ofs0   = df0.xy;
    ofs1   = df1.xy;
		ofs    = df.xy;
		df_hit = df;
		hit = 1;
		break;
	}

  l += df.z;

  if (l >= |d_bound|)
     break;
}

// continue process
if(hit == 1){
  // calculate normal

  vec3 ep = vec3(0.001, 0.0, 0.0);
  nor = vec3(0.0);

  // disable tex_ofs computations
//  #define NO_TEX_OFS 1

  // nor.x
  pos = pos_hit + ep.xyy;
  %df%
  float norx1 = df.z;

  pos = pos_hit - ep.xyy;
  %df%
  float norx2 = df.z;
  nor.x = norx1 - norx2;

  // nor.y
  pos = pos_hit + ep.yxy;
  %df%
  float nory1 = df.z;

  pos = pos_hit - ep.yxy;
  %df%
  float nory2 = df.z;
  nor.y = nory1 - nory2;

  // nor.z
  pos = pos_hit + ep.yyx;
  %df%
  float norz1 = df.z;

  pos = pos_hit - ep.yyx;
  %df%
  float norz2 = df.z;
  nor.z = norz1 - norz2;

  //#undef NO_TEX_OFS

  nor = normalize(nor);

  // get texture
  a = 1.0;
  %a%

  // get texture/seed value
  df = df_hit;
  w = 1.0;
  %seed_color%
	seed0 = seed;

  // compute phong lighting
  %distance_light%
	light0 = light;

	// reflections?
  l = 0.001;
	r_eye = pos_hit; // start where we hit
	r_dir = normalize(reflect(pos_hit, nor)); // reflect the incoming ray over the surface normal
	hit = 0;
	seed1 = vec4(0.0);
  for (int count=0; count < ~d_max_steps~; count += 1) { // arbitray max
  	pos = r_eye + l * r_dir;
	  pos_hit = pos;
    %df%

    // we have a hit
    if (df.z < ~d_epsilon~){
	    ofs0   = df0.xy;
      ofs1   = df1.xy;
		  ofs    = df.xy;
		  df_hit = df;
		  hit = 1;
		  break;
  	}

    l += df.z;

    if (l >= |d_bound|) // thing more about the bound?
       break;
  }

	// we have a reflected object
	if(hit == 1){

    // get texture
    a = 1.0;
    %a%

    // get texture/seed value
    df = df_hit;
    w = 1.0;

    %seed_color%
			 seed = vec4(1.0);
		seed1 = seed;

    // compute phong lighting
		/*
		%distance_light%
			 light1 = vec3(1.0);//light;
		*/
  }

	// illuminate!
  seed0 = vec4(nor, 1.0);//vec4(light0, 1.0) * seed0;
  //seed1 = vec4(light1, 1.0) * seed1;

	seed = seed0;//mix(seed0, seed1, |refl|);

	// specular lighthing + some textures seem to
	// return NaN or Inf?? - WEIRD
	if(isBorked(seed))
		seed = vec4(0.0, 0.0, 0.0, 1.0);
}
