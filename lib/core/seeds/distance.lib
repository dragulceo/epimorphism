### Module
id seed_distance
component seed_distance
flags {lib, distance}
par {d_bound: 3.0, eye: -1.5, l_exp: 3.0, ao_del: 0.01, ao_k:2.0, refl:0.1}
modules {seed_color:tex_simple0, df:df_multi_anim, distance_light: light_anim, a:alpha_solid}
sub {d_max_steps:200, d_epsilon:0.00001}

### Component
id seed_distance_refl
family seed
default_mod seed_distance
children {seed_color:seed_color, df:distance_field, distance_light: distance_light, a:a}
code &&&
seed = vec4(0.0);

vec4 df, df_hit, df0, df1, seed0, seed1;
vec3 pos, pos_hit, nor, light, light_pos;
vec2 ofs, ofs0, ofs1;
float surface, a, w;

// shoot rays!
int hit = 0;
float l = 0.0;
vec3 r_eye = vec3(0.0, 0.0, |eye|);
vec3 r_dir = normalize(vec3(z.x, z.y, 1.0));

for (int count=0; count < ~d_max_steps~; count += 1) {
	pos = r_eye + l * r_dir;
	pos_hit = pos;

  surface = -1.0;
  %df%

  // we have a hit
  if (df.z < ~d_epsilon~){
    ofs0   = df0.xy;
    ofs1   = df1.xy;
		ofs    = df.xy;
		df_hit = df;
		hit = 1;
		break;
	}

  l += df.z;

  if (l >= |d_bound|)
     break;
}

// continue process
if(hit == 1){
  // calculate normal

  vec3 ep = vec3(0.001, 0.0, 0.0);
  nor = vec3(0.0);

  // disable tex_ofs computations
//  #define NO_TEX_OFS 1

  // nor.x
  pos = pos_hit + ep.xyy;
  %df%
  float norx1 = df.z;

  pos = pos_hit - ep.xyy;
  %df%
  float norx2 = df.z;
  nor.x = norx1 - norx2;

  // nor.y
  pos = pos_hit + ep.yxy;
  %df%
  float nory1 = df.z;

  pos = pos_hit - ep.yxy;
  %df%
  float nory2 = df.z;
  nor.y = nory1 - nory2;

  // nor.z
  pos = pos_hit + ep.yyx;
  %df%
  float norz1 = df.z;

  pos = pos_hit - ep.yyx;
  %df%
  float norz2 = df.z;
  nor.z = norz1 - norz2;

  //#undef NO_TEX_OFS

  nor = normalize(nor);

  // get texture
  a = 1.0;
  %a%

  df = df_hit;
  w = 1.0;
  %seed_color%

  // compute phong lighting
  %distance_light%

	// cast shadow rays
  l = 0.001;
	r_eye = pos_hit; // start where we hit
  r_dir = normalize(light_pos - pos); // point towards light

	float shadow_scale = 1.0;
  for (int count=0; count < ~d_max_steps~; count += 1) { // arbitray max
  	pos = r_eye + l * r_dir;

    %df%

    // we have a hit
    if (df.z < ~d_epsilon~){
  		shadow_scale = 0.0;
  		break;
  	}

		shadow_scale = min(shadow_scale, |l_exp| * df.z / l );

    l += df.z;

    if (l >= |d_bound| / 2.0) // thing more about the bound?
       break;
  }

	// scale the light
	light *= shadow_scale;

	// ambient occlusion (is this worth it?)
	float ao = 1.0;
	for(float i=1.0; i <= 5.0; i++){
  	pos = pos_hit + i * |ao_del| * nor;
    #define NO_TEX_OFS 1
		%df%
    #undef NO_TEX_OFS

		float fact = pow(0.5, i) * (i * |ao_del| - df.z);
		ao -= |ao_k| * fact;
	}

	light *= ao;


  seed0 = vec4(light, 1.0) * seed;

	// reflections (currently some glitch)
  l = 0.01;
	r_eye = pos_hit; // start where we hit
	r_dir = normalize(reflect(pos_hit, nor)); // reflect the incoming ray over the surface normal
	hit = 0;
	seed1 = vec4(0.0);
  for (int count=0; count < ~d_max_steps~; count += 1) { // arbitray max
  	pos = r_eye - l * r_dir;
	  pos_hit = pos;

    %df%

    // we have a hit
    if (df.z < ~d_epsilon~ && df.z >= 0.0){
	    ofs0   = df0.xy;
      ofs1   = df1.xy;
		  ofs    = df.xy;
		  df_hit = df;
		  hit = 1;
		  break;
  	}

    l += df.z;

    if (l >= |d_bound|) // thing more about the bound?
       break;
  }

	// we have a reflected object
	if(hit == 1){
    // calculate new normal
		nor = vec3(0.0);

    // disable tex_ofs computations
    //  #define NO_TEX_OFS 1

    // nor.x
    pos = pos_hit + ep.xyy;
    %df%
    float norx1 = df.z;

    pos = pos_hit - ep.xyy;
    %df%
    float norx2 = df.z;
    nor.x = norx1 - norx2;

    // nor.y
    pos = pos_hit + ep.yxy;
    %df%
    float nory1 = df.z;

    pos = pos_hit - ep.yxy;
    %df%
    float nory2 = df.z;
    nor.y = nory1 - nory2;

    // nor.z
    pos = pos_hit + ep.yyx;
    %df%
    float norz1 = df.z;

    pos = pos_hit - ep.yyx;
    %df%
    float norz2 = df.z;
    nor.z = norz1 - norz2;

    //#undef NO_TEX_OFS

    nor = normalize(nor);

    // get texture
    a = 1.0;
    %a%

    df = df_hit;
    w = 1.0;
    %seed_color%
		//seed = vec4(1.0);

    // compute phong lighting
		%distance_light%
		seed1 = vec4(light, 1.0) * seed;
  }

	// mix in reflection
	seed.rgb = seed0.rgb + seed1.rgb * |refl|;
	//seed = seed0;

	// specular lighthing + some textures seem to
	// return NaN or Inf?? - WEIRD
	if(isBorked(seed))
		seed = vec4(0.0, 0.0, 0.0, 1.0);
}



### Component
id seed_distance
family seed
default_mod seed_distance
children {seed_color:seed_color, df:distance_field, distance_light: distance_light, a:a}
code &&&
seed = vec4(0.0);

vec4 df, seed_refl, seed_base;
vec3 pos, pos_hit, nor, light, light_pos;
vec2 ofs;
float surface, a, w;

// shoot rays!
int hit = 0;
float l = 0.0;
vec3 r_eye = vec3(0.0, 0.0, |eye|);
vec3 r_dir = normalize(vec3(z.x, z.y, 1.0));

for (int count=0; count < ~d_max_steps~; count += 1) {
	pos = r_eye + l * r_dir;
	pos_hit = pos;

  surface = -1.0;
  %df%

  // we have a hit
  if (df.z < ~d_epsilon~){
		ofs = df.xy;
		hit = 1;
		break;
	}

  l += df.z;

  if (l >= |d_bound|)
     break;
}

// continue process
if(hit == 1){
  // calculate normal

  vec3 ep = vec3(0.001, 0.0, 0.0);
  nor = vec3(0.0);

  // disable tex_ofs computations
//  #define NO_TEX_OFS 1

  // nor.x
  pos = pos_hit + ep.xyy;
  %df%
  float norx1 = df.z;

  pos = pos_hit - ep.xyy;
  %df%
  float norx2 = df.z;
  nor.x = norx1 - norx2;

  // nor.y
  pos = pos_hit + ep.yxy;
  %df%
  float nory1 = df.z;

  pos = pos_hit - ep.yxy;
  %df%
  float nory2 = df.z;
  nor.y = nory1 - nory2;

  // nor.z
  pos = pos_hit + ep.yyx;
  %df%
  float norz1 = df.z;

  pos = pos_hit - ep.yyx;
  %df%
  float norz2 = df.z;
  nor.z = norz1 - norz2;

  //#undef NO_TEX_OFS

  nor = normalize(nor);

  // get texture
  a = 1.0;
  %a%

  w = 1.0;
  %seed_color%

  // compute phong lighting
  %distance_light%

	// cast shadow rays
  l = 0.001;
	r_eye = pos_hit; // start where we hit
  r_dir = normalize(light_pos - pos); // point towards light

	float shadow_scale = 1.0;
  for (int count=0; count < ~d_max_steps~; count += 1) { // arbitray max
  	pos = r_eye + l * r_dir;

    %df%

    // we have a hit
    if (df.z < ~d_epsilon~){
  		shadow_scale = 0.0;
  		break;
  	}

		shadow_scale = min(shadow_scale, |l_exp| * df.z / l );

    l += df.z;

    if (l >= |d_bound| / 2.0) // thing more about the bound?
       break;
  }

	// scale the light
	light *= shadow_scale;


	// ambient occlusion (is this worth it?)
	float ao = 1.0;
	for(float i=1.0; i <= 5.0; i++){
  	pos = pos_hit + i * |ao_del| * nor;
    #define NO_TEX_OFS 1
		%df%
    #undef NO_TEX_OFS

		float fact = pow(0.5, i) * (i * |ao_del| - df.z);
		ao -= |ao_k| * fact;
	}
	light *= ao;

  seed_base = vec4(light, 1.0) * seed;

	// mix in reflection
	seed = seed_base;
	//seed.rgb = seed_base.rgb + seed_refl.rgb * |refl|;
	//seed = seed0;


	// mix in reflection
	//seed.rgb = seed.rgb + seed1.rgb * |refl|;
	//seed = seed;

	// specular lighthing + some textures seem to
	// return NaN or Inf?? - WEIRD
	if(isBorked(seed))
		seed = vec4(0.0, 0.0, 0.0, 1.0);
}
