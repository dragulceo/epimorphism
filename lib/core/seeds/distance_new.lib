###Module
id seed_distance
component seed_distance
flags {lib, distance}
par {d: wave 0.044 0.1 0.45}
modules {tex:tex_color_dist1, df:df_sphere}

###Component
id seed_distance
family seed
default_mod seed_distance
children {tex:seed_color, df:distance_field}
code &&&

vec4 df;

seed = vec4(0.0, 0.0, 0.0, 0.0);

vec3 r_eye = vec3(0.0, 0.0, -1.5);
vec3 r_dir = normalize(vec3(z.x, z.y, 1.0));

float d = |d|;

// intersect ray
float l = 0.0;

for (int count=0; count < D_MAX_STEPS; count += 1) {
  vec3 pos = r_eye + l * r_dir;

  %df%

  float dist = df.w;

  // we have a hit
  if (dist < D_EPSILON){
     vec2 ofs = df.xy;

     // calculate normal
     vec3 ep = vec3(0.001, 0.0, 0.0);
     vec3 nor = vec3(0.0, 0.0, 0.0);
     vec3 pos_orig = pos;

     // nor.x
     pos = pos_orig + ep.xyy;
     %df%
     float norx1 = df.w;

     pos = pos_orig - ep.xyy;
     %df%
     float norx2 = df.w;
     nor.x = norx1 - norx2;

     // nor.y
     pos = pos_orig + ep.yxy;
     %df%
     float nory1 = df.w;

     pos = pos_orig - ep.yxy;
     %df%
     float nory2 = df.w;
     nor.y = nory1 - nory2;

     // nor.z
     pos = pos_orig + ep.yyx;
     %df%
     float norz1 = df.w;

     pos = pos_orig - ep.yyx;
     %df%
     float norz2 = df.w;
     nor.z = norz1 - norz2;

     nor = normalize(nor);

     // get texture/seed value
     %tex%

     // compute phong lighting
     float shininess = 16.0;
     vec3 ev = normalize(l * r_dir);
     vec3 ref_ev = reflect(ev, nor);

     vec3 light = vec3(0.0);

     //vec3 light_pos   = vec3(5.0 * cos(time), 5.0 * sin(time), -5.0);
     vec3 light_pos   = vec3(5.0, 5.0, -8.0);
     vec3 light_color = vec3(1.0, 0.7, 0.7);

     vec3 vl = normalize(light_pos - pos + vec3(seed.r));

     float diffuse  = max(0.0, dot(vl, nor));
     float specular = max(0.0, dot(vl, ref_ev));

     float v = (seed.r + seed.g + seed.b) / 3.0;
     specular = pow(specular, shininess * v);

     light += light_color * (diffuse + specular);

     // illuminate texture
     seed = vec4(light, 1.0) * seed;

     break;
  }

  l += dist;

  if (l > D_BOUND)
     break;
}


###Module
id df_sphere
component df_sphere
flags {lib, distance}

###Component
id df_sphere
family distance_field
default_mod df_sphere
code &&&

vec3 p = pos;

p = rotate3D(p, vec3(1.0, 0.3, -0.2), time / 8.0);
vec3 sc = p / vec3(d, d, d);

vec2 ofs;

if(abs(sc.z) > 1.0)
  ofs = sc.xy;
else
  ofs = sc.zx;
ofs = (ofs + vec2(1.0, 1.0)) / vec2(2.0, 2.0);

float l = length(p) - 1.0;

df = vec4(ofs, 0.0, l);
