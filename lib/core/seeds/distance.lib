###Module
id seed_distance
component seed_distance
flags {lib, distance}
par {d_bound: 2.0}
modules {tex:tex_simple, df:df_sphere, distance_light: light1}

###Component
id seed_distance
family seed
default_mod seed_distance
children {tex:seed_color, df:distance_field, distance_light: distance_light}
code &&&

#define D_EPSILON 0.00001
#define D_MAX_STEPS 400

vec3 df;

seed = vec4(0.0, 0.0, 0.0, 0.0);

vec3 r_eye = vec3(0.0, 0.0, -1.5);
vec3 r_dir = normalize(vec3(z.x, z.y, 1.0));

// intersect ray
float l = 0.0;

for (int count=0; count < D_MAX_STEPS; count += 1) {
  vec3 pos = r_eye + l * r_dir;
  vec3 pos_orig = pos;

  %df%

  float dist = df.z;

  // we have a hit
  if (dist < D_EPSILON){
     vec2 ofs = df.xy;

     // calculate normal
     vec3 ep = vec3(0.001, 0.0, 0.0);
     vec3 nor = vec3(0.0, 0.0, 0.0);

     // nor.x
     pos = pos_orig + ep.xyy;
     %df%
     float norx1 = df.z;

     pos = pos_orig - ep.xyy;
     %df%
     float norx2 = df.z;
     nor.x = norx1 - norx2;

     // nor.y
     pos = pos_orig + ep.yxy;
     %df%
     float nory1 = df.z;

     pos = pos_orig - ep.yxy;
     %df%
     float nory2 = df.z;
     nor.y = nory1 - nory2;

     // nor.z
     pos = pos_orig + ep.yyx;
     %df%
     float norz1 = df.z;

     pos = pos_orig - ep.yyx;
     %df%
     float norz2 = df.z;
     nor.z = norz1 - norz2;

     nor = normalize(nor);
     pos = pos_orig;

     // get texture/seed value
     %tex%

     // compute phong lighting
     vec3 light = vec3(0.0);
     %distance_light%
     seed = vec4(light, 1.0) * seed;

     break;
  }

  l += dist;

  if (l > |d_bound|)
     break;
}