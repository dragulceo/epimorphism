### Module
id seed_distance
component seed_distance
flags {lib, distance}
par {d_bound: 3.0, eye: -1.5}
modules {seed_color:tex_df_surface, df:df_multi, distance_light: light_simple, a:alpha_solid}
sub {d_max_steps:200, d_epsilon:0.00001}

### Component
id seed_distance
family seed
default_mod seed_distance
children {seed_color:seed_color, df:distance_field, distance_light: distance_light, a:a}
code &&&

vec4 df, df0, df1;
vec2 ofs, ofs0, ofs1;

seed = vec4(0.0);

vec3 r_eye = vec3(0.0, 0.0, |eye|);
vec3 r_dir = normalize(vec3(z.x, z.y, 1.0));

// intersect ray
float l = 0.0;
float surface = -1.0;

for (int count=0; count < ~d_max_steps~; count += 1) {
  /*
  float c = cos(5.0*pos.y);
  float s = sin(5.0*pos.y);
  mat2  m = mat2(c,-s,s,c);
  pos = vec3(m*pos.xz,pos.y);
  */

  /*
  vec3 c = vec3(3.0, 3.0, 3.0);
  pos = mod(pos, c) - 0.5 * c;
  */

	vec3 pos = r_eye + l * r_dir;
	vec3 pos_orig = pos;

  %df%
  float dist = df.z;

  // we have a hit
  if (dist < ~d_epsilon~){
    vec2 ofs0_hit = df0.xy;
    vec2 ofs1_hit = df1.xy;
		vec4 df_hit  = df;

    // calculate normal
    vec3 ep = vec3(0.001, 0.0, 0.0);
    vec3 nor = vec3(0.0, 0.0, 0.0);

		// disable tex_ofs computations
		#define NO_TEX_OFS 1

    // nor.x
    pos = pos_orig + ep.xyy;
    %df%
    float norx1 = df.z;

    pos = pos_orig - ep.xyy;
    %df%
    float norx2 = df.z;
    nor.x = norx1 - norx2;

    // nor.y
    pos = pos_orig + ep.yxy;
    %df%
    float nory1 = df.z;

    pos = pos_orig - ep.yxy;
    %df%
    float nory2 = df.z;
    nor.y = nory1 - nory2;

    // nor.z
    pos = pos_orig + ep.yyx;
    %df%
    float norz1 = df.z;

    pos = pos_orig - ep.yyx;
    %df%
    float norz2 = df.z;
    nor.z = norz1 - norz2;

		#undef NO_TEX_OFS

    nor = normalize(nor);

		float a = 1.0;
		%a%

		ofs0 = ofs0_hit;
		ofs1 = ofs1_hit;
		df = df_hit;
		// get texture/seed value
		float w = 1.0;
    %seed_color%

    // compute phong lighting & illuminate
    vec3 light = vec3(0.0);
    %distance_light%

    seed = vec4(light, 1.0) * seed;

		// specular lighthing + some textures seem to
		// return NaN or Inf?? - WEIRD
		if(isBorked(seed))
			seed = vec4(0.0, 0.0, 0.0, 1.0);

    break;
  }

  l += dist;

  if (l >= |d_bound|)
     break;
}
