###Module
id df_sphere
component df_sphere
flags {lib, distance}
par {diam: 1.0, tex_sc: wave 0.044 0.1 0.45}
modules {cam_trans: trans1}

###Component
id df_sphere
family distance_field
default_mod df_sphere
children {cam_trans: cam_trans}
code &&&

%cam_trans%

vec3 sc = pos / vec3(|tex_sc|, |tex_sc|, |tex_sc|);
vec2 ofs;

if(abs(sc.z) > 1.0)
  ofs = sc.xy;
else
  ofs = sc.zx;
ofs = (ofs + vec2(1.0, 1.0)) / vec2(2.0, 2.0);

float l = length(pos) - |diam|;

df = vec3(ofs, l);


###Module
id df_cylinder
component df_cylinder
flags {lib, distance}
par {diam: wave 0.044 0.1 0.45}
modules {cam_trans: trans_no}

###Component
id df_cylinder
family distance_field
default_mod df_cylinder
children {cam_trans: cam_trans}
code &&&

%cam_trans%

float l = length(pos.xz) - |diam|;

vec2 ofs;
ofs = vec2(atan(pos.x, pos.z) / PI, pos.y / (2.0 * PI * |diam|));
ofs = (ofs + vec2(1.0, 1.0)) / vec2(2.0, 2.0);

df = vec3(ofs, l);


###Module
id df_cube
component df_cube
flags {lib, distance}
par {diam: 0.5}
modules {cam_trans: trans1}

###Component
id df_cube
family distance_field
default_mod df_cube
children {cam_trans: cam_trans}
code &&&

%cam_trans%

vec3 d  = abs(pos) - vec3(|diam|, |diam|, |diam|);
float l = min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));

// TODO: finish me
vec2 ofs;
ofs = vec2(atan(pos.x, pos.z) / PI, pos.y / (2.0 * PI * |diam|));
ofs = (ofs + vec2(1.0, 1.0)) / vec2(2.0, 2.0);

df = vec3(ofs, l);


###Module
id df_torus
component df_torus
flags {lib, distance}
par {diam1: 0.7, diam2: 0.2}
modules {cam_trans: trans1}

###Component
id df_torus
family distance_field
default_mod df_torus
children {cam_trans: cam_trans}
code &&&

%cam_trans%

vec2 q = vec2(length(pos.xz) - |diam1|, pos.y);
float l = length(q) - |diam2|;

// TODO: finish me
vec2 ofs;
ofs = vec2(atan(pos.x, pos.z) / PI, pos.y / (2.0 * PI * |diam2|));
ofs = (ofs + vec2(1.0, 1.0)) / vec2(2.0, 2.0);

df = vec3(ofs, l);
