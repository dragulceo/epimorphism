###Module
id seed_distance
component seed_distance
flags {lib, distance}
modules {t_seed:t_wrap, reduce:torus_reduce, tex:tex_color_dist}

###Module
id tex_color_dist
component tex_simple
flags {lib}
images [textures/simplegeom/tile_grid1.png]
par {scale:1.0}
scripts [randomize dly:10 spd:0.5 lib:1024 dim:vec4 sub:0 typ:image]

### Component
id tex_simple
family seed_color
default_mod tex_color_dist
code &&&
ofs = vec2(2.0, 2.0) * ofs - vec2(1.0, 1.0);
ofs = |scale| * torus_reduce(ofs);
ofs = (ofs + vec2(1.0, 1.0)) / vec2(2.0, 2.0);
seed = texture2D(aux[#0], ofs);

###Component
id seed_distance
family seed
default_mod seed_distance
children {t_seed:t, reduce:reduce, tex:seed_color}
code &&&
%reduce% // add an additional layer of symmetry; is this necessary
%t_seed% // is this necessary
%reduce% // is this necessary?

vec3 r_eye = vec3(0.0, 0.0, -1.5);
vec3 r_dir = normalize(vec3(z.x, z.y, 1.0));

vec4 res = inter(r_eye, r_dir, time);
float hit = res.w;
vec2 ofs = res.xy;

// generate color(z)
if (hit >= 0.0) {
  vec3 pos = r_eye + hit * r_dir;
  vec3 n = calcNormal(pos, time);  

  // compute phong lighting
  float shininess = 16.0; 
  vec3 ev = normalize(hit * r_dir);
  vec3 ref_ev = reflect(ev, n);

  vec3 light = vec3(0.0);

  { 
    //vec3 light_pos   = vec3(5.0 * cos(time), 5.0 * sin(time), -5.0);
    vec3 light_pos   = vec3(5.0, 5.0, -8.0);    
    vec3 light_color = vec3(1.0, 0.7, 0.7);
    
    vec3 vl = normalize(light_pos - pos);
    
    float diffuse  = max(0.0, dot(vl, n));
    float specular = max(0.0, dot(vl, ref_ev));
    specular = pow(specular, shininess);
    
    light += light_color * (diffuse + specular);
  }

/*
  { 
    //vec3 light_pos   = vec3(-5.0, cos(time / 2.0) * 5.0, sin(time / 2.0) * cos(time) * -5.0);
    vec3 light_pos   = vec3(5.0, -5.0, -5.0);        
    vec3 light_color = vec3(0.3, 0.7, 1.0);
    
    vec3 vl = normalize(light_pos - pos);
    
    float diffuse  = max(0.0, dot(vl, n));
    float specular = max(0.0, dot(vl, ref_ev));
    specular = pow(specular, shininess);
    
    light += light_color * (diffuse + specular);
  }
*/
  %tex% 

  // illuminate texture
  seed = vec4(light, 1.0) * seed;
}else
  seed = vec4(0.0, 0.0, 0.0, 0.0);


//seed = vec4(z.x, z.y, 0.0, 1.0);